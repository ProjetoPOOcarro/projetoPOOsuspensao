-- Implementação Java 1: (Sugestão GENÉRICA GPT)

import java.util.Arrays;

public class QuarterCarSimulation {

    public static void main(String[] args) {
        // Parameters
        double m_s = 250;    // Sprung mass (kg)
        double m_u = 50;     // Unsprung mass (kg)
        double k_s = 15000;  // Suspension stiffness (N/m)
        double k_t = 200000; // Tire stiffness (N/m)
        double c_s = 1000;   // Suspension damping (Ns/m)

        // State-space matrices
        double[][] A = {
            {0, 1, 0, 0},
            {-k_s / m_s, -c_s / m_s, k_s / m_s, c_s / m_s},
            {0, 0, 0, 1},
            {k_s / m_u, c_s / m_u, -(k_s + k_t) / m_u, -c_s / m_u}
        };
        double[] B = {0, 0, 0, k_t / m_u};
        double[][] C = {
            {1, 0, 0, 0},  // Sprung mass displacement
            {0, 0, 1, 0}   // Unsprung mass displacement
        };
        double[] D = {0, 0};

        // Simulation parameters
        double dt = 0.01;               // Time step (s)
        double tMax = 5.0;              // Simulation duration (s)
        int steps = (int) (tMax / dt);  // Total simulation steps
        double[] u = new double[steps]; // Road disturbance input

        // Generate road disturbance (sinusoidal input)
        for (int i = 0; i < steps; i++) {
            u[i] = 0.1 * Math.sin(2 * Math.PI * i * dt);
        }

        // Initial state
        double[] x = {0, 0, 0, 0}; // Initial conditions: [x_s, x'_s, x_u, x'_u]

        // Results storage
        double[][] y = new double[steps][2]; // Output: y[time][metric]
        double[][] states = new double[steps][4]; // State variables

        // Simulation loop
        for (int i = 0; i < steps; i++) {
            // Store current outputs
            y[i] = matrixVectorMultiply(C, x);  // y = Cx + Du (ignore D here)
            states[i] = Arrays.copyOf(x, 4);    // Save state

            // Compute state derivative: dx = Ax + Bu
            double[] dx = addVectors(matrixVectorMultiply(A, x), scalarMultiply(B, u[i]));

            // Update state using Euler method: x = x + dx * dt
            x = addVectors(x, scalarMultiply(dx, dt));
        }

        // Analyze results (metrics)
        for (int i = 0; i < steps; i++) {
            double x_s_ddot = matrixVectorMultiply(A, states[i])[1]; // Second derivative of x_s
            double relativeDisplacement = states[i][2] - states[i][0]; // x_u - x_s

            System.out.printf("Time: %.2f, x''_s: %.4f, (x_u - x_s): %.4f\n",
                              i * dt, x_s_ddot, relativeDisplacement);
        }
    }

    // Helper: Matrix-vector multiplication
    public static double[] matrixVectorMultiply(double[][] matrix, double[] vector) {
        double[] result = new double[matrix.length];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < vector.length; j++) {
                result[i] += matrix[i][j] * vector[j];
            }
        }
        return result;
    }

    // Helper: Add two vectors
    public static double[] addVectors(double[] a, double[] b) {
        double[] result = new double[a.length];
        for (int i = 0; i < a.length; i++) {
            result[i] = a[i] + b[i];
        }
        return result;
    }

    // Helper: Scalar multiply a vector
    public static double[] scalarMultiply(double[] vector, double scalar) {
        double[] result = new double[vector.length];
        for (int i = 0; i < vector.length; i++) {
            result[i] = vector[i] * scalar;
        }
        return result;
    }
}
